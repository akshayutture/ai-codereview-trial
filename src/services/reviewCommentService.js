import { logger } from '../utils/logger.js';
import { githubService } from './githubService.js';

class ReviewCommentService {
  constructor() {
    this.botSignature = '\n\n---\n🤖 *This comment was generated by the GitHub Code Review Agent*';
  }

  async postReviewComments(owner, repo, pullNumber, analysisResults) {
    if (!analysisResults || analysisResults.length === 0) {
      logger.info('No review comments to post', {
        owner,
        repo,
        pullNumber
      });
      return;
    }

    logger.info('Posting review comments', {
      owner,
      repo,
      pullNumber,
      commentCount: analysisResults.length
    });

    try {
      // Group comments by severity and category for summary
      const summary = this.generateReviewSummary(analysisResults);
      
      // Create individual review comments
      const reviewComments = analysisResults.map(result => ({
        path: result.path,
        line: result.line,
        body: this.formatComment(result)
      }));

      // Create a comprehensive review
      await githubService.createReview(owner, repo, pullNumber, {
        body: summary + this.botSignature,
        event: this.determineReviewEvent(analysisResults),
        comments: reviewComments
      });

      logger.info('Successfully posted review', {
        owner,
        repo,
        pullNumber,
        commentCount: reviewComments.length
      });

    } catch (error) {
      logger.error('Failed to post review comments', {
        owner,
        repo,
        pullNumber,
        error: error.message,
        commentCount: analysisResults.length
      });

      // Fallback: try to post individual comments
      await this.postIndividualComments(owner, repo, pullNumber, analysisResults);
    }
  }

  async postIndividualComments(owner, repo, pullNumber, analysisResults) {
    logger.info('Posting individual review comments as fallback', {
      owner,
      repo,
      pullNumber,
      commentCount: analysisResults.length
    });

    const successfulComments = [];
    const failedComments = [];

    for (const result of analysisResults) {
      try {
        await githubService.createReviewComment(owner, repo, pullNumber, {
          path: result.path,
          line: result.line,
          body: this.formatComment(result)
        });
        successfulComments.push(result);
      } catch (error) {
        logger.error('Failed to post individual comment', {
          owner,
          repo,
          pullNumber,
          path: result.path,
          line: result.line,
          error: error.message
        });
        failedComments.push(result);
      }
    }

    logger.info('Individual comments posting completed', {
      owner,
      repo,
      pullNumber,
      successful: successfulComments.length,
      failed: failedComments.length
    });
  }

  formatComment(result) {
    const severityEmoji = {
      error: '🚨',
      warning: '⚠️',
      info: 'ℹ️'
    };

    const categoryEmoji = {
      bug: '🐛',
      security: '🔒',
      performance: '⚡',
      style: '🎨',
      maintainability: '🔧',
      general: '💡'
    };

    let comment = `${severityEmoji[result.severity] || 'ℹ️'} ${categoryEmoji[result.category] || '💡'} **${this.capitalizeFirst(result.category || 'General')} ${this.capitalizeFirst(result.severity || 'Info')}**\n\n`;
    
    comment += result.body;

    if (result.suggestion) {
      comment += `\n\n**💡 Suggestion:**\n${result.suggestion}`;
    }

    comment += this.botSignature;

    return comment;
  }

  generateReviewSummary(analysisResults) {
    const stats = this.calculateStats(analysisResults);
    
    let summary = `## 🤖 Code Review Summary\n\n`;
    summary += `I've analyzed the code changes and found **${analysisResults.length}** item(s) to review:\n\n`;

    if (stats.errors > 0) {
      summary += `- 🚨 **${stats.errors}** error(s) that should be addressed\n`;
    }
    if (stats.warnings > 0) {
      summary += `- ⚠️ **${stats.warnings}** warning(s) to consider\n`;
    }
    if (stats.info > 0) {
      summary += `- ℹ️ **${stats.info}** informational note(s)\n`;
    }

    summary += `\n### 📊 Issues by Category\n`;
    Object.entries(stats.categories).forEach(([category, count]) => {
      if (count > 0) {
        const emoji = {
          bug: '🐛',
          security: '🔒',
          performance: '⚡',
          style: '🎨',
          maintainability: '🔧',
          general: '💡'
        }[category] || '💡';
        summary += `- ${emoji} ${this.capitalizeFirst(category)}: ${count}\n`;
      }
    });

    summary += `\nPlease review the specific comments below for detailed feedback on each issue.\n\n`;

    return summary;
  }

  calculateStats(analysisResults) {
    const stats = {
      errors: 0,
      warnings: 0,
      info: 0,
      categories: {
        bug: 0,
        security: 0,
        performance: 0,
        style: 0,
        maintainability: 0,
        general: 0
      }
    };

    analysisResults.forEach(result => {
      // Count by severity
      if (result.severity === 'error') stats.errors++;
      else if (result.severity === 'warning') stats.warnings++;
      else stats.info++;

      // Count by category
      const category = result.category || 'general';
      if (stats.categories.hasOwnProperty(category)) {
        stats.categories[category]++;
      } else {
        stats.categories.general++;
      }
    });

    return stats;
  }

  determineReviewEvent(analysisResults) {
    // Determine the review event based on the severity of issues found
    const hasErrors = analysisResults.some(result => result.severity === 'error');
    const hasWarnings = analysisResults.some(result => result.severity === 'warning');

    if (hasErrors) {
      return 'REQUEST_CHANGES';
    } else if (hasWarnings) {
      return 'COMMENT';
    } else {
      return 'COMMENT'; // For info-level comments
    }
  }

  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

export const reviewCommentService = new ReviewCommentService();
